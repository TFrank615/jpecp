<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Meta tags for full-screen web app on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="JPECP Protocols">

    <title>JPECP EMS Protocols</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple transition for a smoother experience */
        .page {
            transition: transform 0.3s ease-in-out;
        }
        /* Hide scrollbar for cleaner look on mobile */
        ::-webkit-scrollbar {
            display: none;
        }
        html, body {
            overscroll-behavior-y: contain;
        }
        /* Basic loader animation */
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Styles for collapsible categories */
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .chevron {
             transition: transform 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <div id="app-container" class="h-full w-full max-w-md mx-auto bg-white shadow-lg relative overflow-hidden">

        <!-- Main Page: Protocol List -->
        <div id="main-page" class="page absolute top-0 left-0 w-full h-full flex flex-col">
            <!-- Header -->
            <header class="bg-blue-600 text-white p-4 shadow-md z-10">
                <h1 class="text-2xl font-bold text-center">JPECP EMS Protocols</h1>
            </header>

            <!-- Search Bar -->
            <div class="p-4 bg-gray-50 border-b border-gray-200">
                <input type="text" id="search-bar" placeholder="Search protocols..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>

            <!-- Protocol List -->
            <main id="protocol-list" class="flex-grow overflow-y-auto pb-4">
                <!-- Protocol categories and items will be injected here by JavaScript -->
            </main>
        </div>

        <!-- Detail Page: Protocol Content -->
        <div id="detail-page" class="page absolute top-0 left-0 w-full h-full bg-white flex flex-col transform translate-x-full">
            <!-- Detail Header -->
            <header class="bg-gray-800 text-white p-4 shadow-md flex items-center z-10">
                <button id="back-button" class="mr-4 p-2 rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <h2 id="detail-title" class="text-xl font-semibold truncate">Protocol Details</h2>
            </header>

            <!-- Protocol Content -->
            <div id="detail-content" class="flex-grow overflow-y-auto p-6">
                <!-- Protocol content will be injected here -->
            </div>
        </div>

    </div>

    <script>
        // --- CONFIGURATION ---
        const LOCAL_CSV_PATH = 'protocols.csv'; // Path to your local CSV file

        // --- DATA ---
        let protocolData = []; // This will be populated by the fetch from the local CSV.

        // --- DOM ELEMENTS ---
        const mainPage = document.getElementById('main-page');
        const detailPage = document.getElementById('detail-page');
        const protocolListContainer = document.getElementById('protocol-list');
        const searchBar = document.getElementById('search-bar');
        const backButton = document.getElementById('back-button');
        const detailTitle = document.getElementById('detail-title');
        const detailContent = document.getElementById('detail-content');

        // --- FUNCTIONS ---
        
        /**
         * Debounce function to delay execution of a function until after a certain time
         * has passed without it being called. Useful for search input.
         * @param {Function} func The function to debounce.
         * @param {number} delay The delay in milliseconds.
         */
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }
       
       /**
         * Parses CSV text into a structured data format.
         * @param {string} csvText - The raw CSV string from the Google Sheet.
         * @returns {Array} An array of arrays, representing rows and fields.
         */
        function parseCSV(csvText) {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;
            const normalizedText = csvText.trim().replace(/\r\n/g, '\n');

            for (let i = 0; i < normalizedText.length; i++) {
                const char = normalizedText[i];
                const nextChar = normalizedText[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        currentField += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    currentRow.push(currentField);
                    currentField = '';
                } else if (char === '\n' && !inQuotes) {
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            if (currentField || currentRow.length > 0) {
                 currentRow.push(currentField);
                 rows.push(currentRow);
            }
            return rows;
        }

        /**
         * Groups the parsed CSV data by category.
         * @param {Array} rows - The parsed CSV data from parseCSV.
         * @returns {Array} The structured protocol data.
         */
        function groupProtocols(rows) {
            if (rows.length < 2) return [];
            
            const headers = rows.shift().map(h => h.trim().toLowerCase());
            const categoryIndex = headers.indexOf('category');
            const titleIndex = headers.indexOf('title');
            const contentIndex = headers.indexOf('content');

            if (categoryIndex === -1 || titleIndex === -1 || contentIndex === -1) {
                throw new Error(`CSV headers must include 'category', 'title', and 'content'. Found headers: ${headers.join(', ')}`);
            }
            
            const dataMap = new Map();
            rows.forEach(row => {
                if (row.length < headers.length) return;
                const category = row[categoryIndex];
                const title = row[titleIndex];
                const content = row[contentIndex] || '';
                if (!category || !title) return;
                if (!dataMap.has(category)) {
                    dataMap.set(category, []);
                }
                dataMap.get(category).push({ title, content });
            });

            const groupedData = [];
            dataMap.forEach((protocols, category) => {
                groupedData.push({ category, protocols });
            });
            return groupedData;
        }

        /**
         * Renders the protocols into the main list with collapsible categories.
         * @param {Array} data - The protocol data to render.
         */
        function renderProtocols(data) {
            protocolListContainer.innerHTML = ''; // Clear existing list
            if (data.length === 0) {
                protocolListContainer.innerHTML = `<p class="text-center text-gray-500 mt-8">No protocols found.</p>`;
                return;
            }
            data.forEach(category => {
                const categoryContainer = document.createElement('div');
                const categoryHeader = document.createElement('button');
                categoryHeader.className = 'w-full text-left text-lg font-semibold bg-gray-200 p-3 mt-4 sticky top-0 flex justify-between items-center focus:outline-none focus:ring-2 focus:ring-blue-500 z-10 cursor-pointer';
                categoryHeader.innerHTML = `
                    <span>${category.category}</span>
                    <svg class="chevron h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                `;
                const list = document.createElement('ul');
                list.className = 'divide-y divide-gray-200 collapsible-content';
                category.protocols.forEach(protocol => {
                    const listItem = document.createElement('li');
                    listItem.className = 'p-4 hover:bg-blue-50 cursor-pointer flex justify-between items-center';
                    listItem.innerHTML = `<span>${protocol.title}</span><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>`;
                    listItem.addEventListener('click', () => showDetail(protocol));
                    list.appendChild(listItem);
                });
                categoryContainer.appendChild(categoryHeader);
                categoryContainer.appendChild(list);
                protocolListContainer.appendChild(categoryContainer);
                list.style.maxHeight = '0px';
                categoryHeader.querySelector('.chevron').style.transform = 'rotate(-180deg)';
                categoryHeader.addEventListener('click', () => {
                    const isExpanded = list.style.maxHeight !== '0px';
                    const chevron = categoryHeader.querySelector('.chevron');
                    if (isExpanded) {
                        list.style.maxHeight = '0px';
                        chevron.style.transform = 'rotate(-180deg)';
                    } else {
                        list.style.maxHeight = list.scrollHeight + 'px';
                        chevron.style.transform = 'rotate(0deg)';
                    }
                });
            });
        }

        /**
         * Filters and re-renders the protocol list based on search input.
         */
        function handleSearch() {
            const query = searchBar.value.toLowerCase();
            if (!query) {
                renderProtocols(protocolData);
                return;
            }
            const filteredData = protocolData.map(category => {
                const filteredProtocols = category.protocols.filter(protocol =>
                    protocol.title.toLowerCase().includes(query) ||
                    protocol.content.toLowerCase().includes(query)
                );
                return { ...category, protocols: filteredProtocols };
            }).filter(category => category.protocols.length > 0);
            renderProtocols(filteredData);
        }

        /**
         * Shows the detail page with the content of the selected protocol.
         * @param {Object} protocol - The protocol object to display.
         */
        function showDetail(protocol) {
            detailTitle.textContent = protocol.title;
            detailContent.innerHTML = protocol.content;
            detailContent.scrollTop = 0;
            mainPage.style.transform = 'translateX(-100%)';
            detailPage.style.transform = 'translateX(0)';
        }

        /**
         * Hides the detail page and shows the main list.
         */
        function hideDetail() {
            mainPage.style.transform = 'translateX(0)';
            detailPage.style.transform = 'translateX(100%)';
        }

        /**
         * Fetches, parses, and renders the protocols from a local CSV file.
         */
        async function initializeApp() {
            protocolListContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center mt-10">
                    <div class="loader mb-4"></div>
                    <p class="text-gray-600">Loading protocols...</p>
                </div>`;

            try {
                const response = await fetch(LOCAL_CSV_PATH);
                if (!response.ok) {
                    throw new Error(`Could not load local protocols file (Status: ${response.status}). Make sure 'protocols.csv' is in the same folder as this HTML file.`);
                }
                
                const csvText = await response.text();
                if (!csvText) throw new Error("Local protocols file is empty.");
                
                const rows = parseCSV(csvText);
                protocolData = groupProtocols(rows);
                
                if (protocolData.length === 0) {
                     throw new Error("Parsing failed or no data was found after parsing. Please check that your CSV file has the correct headers ('category', 'title', 'content') and at least one row of data.");
                }

                renderProtocols(protocolData);

            } catch (error) {
                console.error('Initialization failed:', error);
                protocolListContainer.innerHTML = `<div class="text-center text-red-500 p-4 mt-8"><b>Error:</b> ${error.message}</div>`;
            }
        }

        // --- EVENT LISTENERS ---
        // Debounce search input for better performance
        searchBar.addEventListener('input', debounce(handleSearch, 250));
        backButton.addEventListener('click', hideDetail);

        // --- INITIALIZE APP ---
        initializeApp();

    </script>
</body>
</html>

