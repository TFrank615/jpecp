<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JPECP EMS Protocols</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple transition for a smoother experience */
        .page {
            transition: transform 0.3s ease-in-out;
        }
        /* Hide scrollbar for cleaner look on mobile */
        ::-webkit-scrollbar {
            display: none;
        }
        html, body {
            overscroll-behavior-y: contain;
        }
        /* Basic loader animation */
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Styles for collapsible categories */
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .chevron {
             transition: transform 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <div id="app-container" class="h-full w-full max-w-md mx-auto bg-white shadow-lg relative overflow-hidden">

        <!-- Main Page: Protocol List -->
        <div id="main-page" class="page absolute top-0 left-0 w-full h-full flex flex-col">
            <!-- Header -->
            <header class="bg-blue-600 text-white p-4 shadow-md z-10">
                <h1 class="text-2xl font-bold text-center">JPECP EMS Protocols</h1>
            </header>

            <!-- Search Bar -->
            <div class="p-4 bg-gray-50 border-b border-gray-200">
                <input type="text" id="search-bar" placeholder="Search protocols..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>

            <!-- Protocol List -->
            <main id="protocol-list" class="flex-grow overflow-y-auto pb-4">
                <!-- Protocol categories and items will be injected here by JavaScript -->
            </main>
        </div>

        <!-- Detail Page: Protocol Content -->
        <div id="detail-page" class="page absolute top-0 left-0 w-full h-full bg-white flex flex-col transform translate-x-full">
            <!-- Detail Header -->
            <header class="bg-gray-800 text-white p-4 shadow-md flex items-center z-10">
                <button id="back-button" class="mr-4 p-2 rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <h2 id="detail-title" class="text-xl font-semibold truncate">Protocol Details</h2>
            </header>

            <!-- Protocol Content -->
            <div id="detail-content" class="flex-grow overflow-y-auto p-6">
                <!-- Protocol content will be injected here -->
            </div>
        </div>

    </div>

    <script>
        // --- CONFIGURATION ---
        // 1. Follow the instructions in 'instructions.md' to set up and publish your Google Sheet.
        // 2. Paste the PUBLISHED .csv URL you get from Google Sheets here.
        const GOOGLE_SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQBUFuqIIdxow_lZxa7bnjqrMIpAElnsOnIq60o5-xjt6XEMvf2XIw1rxUz6URFWUnpqCYe71P-xLOU/pub?gid=2105512997&single=true&output=csv';

        // --- DATA ---
        let protocolData = []; // This will be populated by the fetch from Google Sheets.

        // --- DOM ELEMENTS ---
        const mainPage = document.getElementById('main-page');
        const detailPage = document.getElementById('detail-page');
        const protocolListContainer = document.getElementById('protocol-list');
        const searchBar = document.getElementById('search-bar');
        const backButton = document.getElementById('back-button');
        const detailTitle = document.getElementById('detail-title');
        const detailContent = document.getElementById('detail-content');

        // --- FUNCTIONS ---
        
       /**
         * Parses CSV text into a structured data format. This version properly handles
         * quoted fields that may contain newlines and commas.
         * @param {string} csvText - The raw CSV string from the Google Sheet.
         * @returns {Array} An array of arrays, representing rows and fields.
         */
        function parseCSV(csvText) {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;

            // Normalize line endings to LF
            const normalizedText = csvText.trim().replace(/\r\n/g, '\n');

            for (let i = 0; i < normalizedText.length; i++) {
                const char = normalizedText[i];
                const nextChar = normalizedText[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // This is an escaped quote inside a quoted field
                        currentField += '"';
                        i++; // Skip the next quote
                    } else {
                        // This is the start or end of a quoted field
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of a field
                    currentRow.push(currentField);
                    currentField = '';
                } else if (char === '\n' && !inQuotes) {
                    // End of a row
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            // Add the last field and row if the file doesn't end with a newline
            if (currentField || currentRow.length > 0) {
                 currentRow.push(currentField);
                 rows.push(currentRow);
            }
            
            return rows;
        }


        /**
         * Groups the parsed CSV data by category.
         * @param {Array} rows - The parsed CSV data from parseCSV.
         * @returns {Array} The structured protocol data.
         */
        function groupProtocols(rows) {
            if (rows.length < 2) return [];
            
            const headers = rows.shift().map(h => h.trim().toLowerCase());
            const categoryIndex = headers.indexOf('category');
            const titleIndex = headers.indexOf('title');
            const contentIndex = headers.indexOf('content');

            if (categoryIndex === -1 || titleIndex === -1 || contentIndex === -1) {
                throw new Error(`CSV headers must include 'category', 'title', and 'content'. Found headers: ${headers.join(', ')}`);
            }
            
            const dataMap = new Map();

            rows.forEach(row => {
                if (row.length < headers.length) return; // Skip malformed rows
                
                const category = row[categoryIndex];
                const title = row[titleIndex];
                const content = row[contentIndex] || '';

                if (!category || !title) return;

                if (!dataMap.has(category)) {
                    dataMap.set(category, []);
                }
                dataMap.get(category).push({ title, content });
            });

            const groupedData = [];
            dataMap.forEach((protocols, category) => {
                groupedData.push({ category, protocols });
            });
            
            return groupedData;
        }

        /**
         * Renders the protocols into the main list with collapsible categories.
         * @param {Array} data - The protocol data to render.
         */
        function renderProtocols(data) {
            protocolListContainer.innerHTML = ''; // Clear existing list
            if (data.length === 0) {
                protocolListContainer.innerHTML = `<p class="text-center text-gray-500 mt-8">No protocols found.</p>`;
                return;
            }
            data.forEach(category => {
                const categoryContainer = document.createElement('div');
                
                const categoryHeader = document.createElement('button');
                categoryHeader.className = 'w-full text-left text-lg font-semibold bg-gray-200 p-3 mt-4 sticky top-0 flex justify-between items-center focus:outline-none focus:ring-2 focus:ring-blue-500 z-10 cursor-pointer';
                categoryHeader.innerHTML = `
                    <span>${category.category}</span>
                    <svg class="chevron h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                `;

                const list = document.createElement('ul');
                list.className = 'divide-y divide-gray-200 collapsible-content';
                
                category.protocols.forEach(protocol => {
                    const listItem = document.createElement('li');
                    listItem.className = 'p-4 hover:bg-blue-50 cursor-pointer flex justify-between items-center';
                    listItem.innerHTML = `<span>${protocol.title}</span><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>`;
                    listItem.addEventListener('click', () => showDetail(protocol));
                    list.appendChild(listItem);
                });
                
                categoryContainer.appendChild(categoryHeader);
                categoryContainer.appendChild(list);
                protocolListContainer.appendChild(categoryContainer);
                
                // Set initial state to collapsed
                list.style.maxHeight = '0px';
                categoryHeader.querySelector('.chevron').style.transform = 'rotate(-180deg)';

                categoryHeader.addEventListener('click', () => {
                    const isExpanded = list.style.maxHeight !== '0px';
                    const chevron = categoryHeader.querySelector('.chevron');
                    if (isExpanded) {
                        list.style.maxHeight = '0px';
                        chevron.style.transform = 'rotate(-180deg)';
                    } else {
                        list.style.maxHeight = list.scrollHeight + 'px';
                        chevron.style.transform = 'rotate(0deg)';
                    }
                });
            });
        }


        /**
         * Filters and re-renders the protocol list based on search input.
         */
        function handleSearch() {
            const query = searchBar.value.toLowerCase();
            if (!query) {
                renderProtocols(protocolData);
                return;
            }

            const filteredData = protocolData.map(category => {
                const filteredProtocols = category.protocols.filter(protocol =>
                    protocol.title.toLowerCase().includes(query) ||
                    protocol.content.toLowerCase().includes(query)
                );
                return { ...category, protocols: filteredProtocols };
            }).filter(category => category.protocols.length > 0);

            renderProtocols(filteredData);
        }

        /**
         * Shows the detail page with the content of the selected protocol.
         * @param {Object} protocol - The protocol object to display.
         */
        function showDetail(protocol) {
            detailTitle.textContent = protocol.title;
            detailContent.innerHTML = protocol.content;
            detailContent.scrollTop = 0;
            mainPage.style.transform = 'translateX(-100%)';
            detailPage.style.transform = 'translateX(0)';
        }

        /**
         * Hides the detail page and shows the main list.
         */
        function hideDetail() {
            mainPage.style.transform = 'translateX(0)';
            detailPage.style.transform = 'translateX(100%)';
        }

        /**
         * Fetches, parses, and renders the protocols from the Google Sheet.
         */
        async function initializeApp() {
            protocolListContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center mt-10">
                    <div class="loader mb-4"></div>
                    <p class="text-gray-600">Loading protocols...</p>
                </div>`;

            if (!GOOGLE_SHEET_URL || GOOGLE_SHEET_URL === 'YOUR_GOOGLE_SHEET_URL_HERE') {
                protocolListContainer.innerHTML = `<p class="text-center text-red-600 p-4 mt-8"><b>Configuration Needed:</b><br>Please paste your published Google Sheet URL into the <code>GOOGLE_SHEET_URL</code> variable in the script.</p>`;
                return;
            }

            // Using a CORS proxy to ensure the data can be fetched reliably from any environment.
            const proxyUrl = 'https://api.allorigins.win/raw?url=';
            // We encode the URL to ensure special characters are handled correctly by the proxy.
            const fetchUrl = proxyUrl + encodeURIComponent(GOOGLE_SHEET_URL);

            try {
                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    throw new Error(`Network Error (Status: ${response.status}). Please check a few things: <br>1. Is your Google Sheet URL correct? <br>2. Did you publish it to the web as a CSV? <br>3. The proxy service might be temporarily unavailable.`);
                }
                const csvText = await response.text();
                
                // For debugging: log the fetched CSV to the console.
                console.log("--- Fetched CSV Data ---");
                console.log(csvText);
                console.log("--- End of CSV Data ---");

                if (!csvText) {
                    throw new Error("Fetched data is empty. Your Google Sheet might be empty or not published correctly.");
                }
                
                const rows = parseCSV(csvText);
                const fetchedData = groupProtocols(rows);
                
                if (fetchedData.length === 0) {
                     throw new Error("Parsing failed or no data was found after parsing. Please check that your Google Sheet has the correct headers ('category', 'title', 'content') and at least one row of data.");
                }
                
                protocolData = fetchedData; // Store globally for search function
                renderProtocols(protocolData);

            } catch (error) {
                console.error('Initialization failed:', error);
                protocolListContainer.innerHTML = `<div class="text-center text-red-500 p-4 mt-8"><b>Error:</b> ${error.message}</div>`;
            }
        }

        // --- EVENT LISTENERS ---
        searchBar.addEventListener('input', handleSearch);
        backButton.addEventListener('click', hideDetail);

        // --- INITIALIZE APP ---
        initializeApp();

    </script>
</body>
</html>

